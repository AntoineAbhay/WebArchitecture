<!doctype html>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Web Architecture</title>
  <meta name="description" content="Web Architecture trends in 2019">
  <meta name="author" content="Antoine ABHAY">
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <header>
    <h1>Web Architecture</h1>
  </header>

  <section class="odd">
    <h2>Comment rester informé sur le sujet ?</h2>
    <a href="https://www.infoq.com/architecture-design">infoQ - architecture and design</a>
  </section>

  <section class="even">
    <h2>Architecture monolythique</h2>
    <p>
      Pour comprendre ce qu'est une architecture en micro-services,
      il faut d'abord comprendre ce qu'est une architecture monolythique.
      Il s'agit de la manière la plus simple de construire un projet (en tout cas au début).
      En effet, le code est réuni en un seul endroit
      et il n'y a qu'une base de données réunissant toutes les informations du système.
    </p>


    <h3>Avantages</h3>
    <p>Ce style d'architecture est très simple à mettre en place et assez naturel.</p>
    <h3>Inconvénients</h3>
    <p>
      <ul>
        <li>Scalabilité
          <p>
            On peut noter une faible scalabilité de cette architecture.
            Bien qu'il soit possible de multiplier les instances derrière un répartiteur de charge,
            il n'y a qu'une seule base de données qui représente un goulot d'étranglement si le système grandit.
            Ce problème peut devenir très coûteux s'il est nécessaire de mettre à l'échelle de manière verticale
            au niveau de la base de donnée (ie. utiliser une machine de plus grande capacité plutôt que de multiplier les machines).
          </p>
        </li>
        <li>Fiabilité
          <p>Il est difficile de tester un gros système en un seul bloc.</p>
        </li>
        <li>Évolutivité
          <p>Les interdépendances au sein du code ne permettent pas de faire évoluer le produit rapidement.</p>
        </li>
        <li>Autonomie des équipes
          <p>
            Les équipes ne sont pas autonomes.
            Elles doivent se concerter en permanence pour connaître les implications des changements
            qu'elles veulent réaliser sur le travail des autres.
            Cela peut par exemple conduire à un grand nombre de "merge conflict" assez pénibles à résoudre.
          </p>
        </li>
      </ul>
    </p>

  </section>

  <section class="odd">
    <h2>Architecture micro-services</h2>
    <p>
      Dans une architecture en micro-services,
      l'application est divisée en bloc applicatifs plus petits.
      Chaque bloc ou micro-service est indépendant des autres
      dans la mesure où les services discutent entre eux uniquement via leur APIs respectives.
      Cette architecture permet de répondre aux principaux problèmes du monolythe
      mais présente également des inconvénients.
    </p>

    <h3>Avantages</h3>
    <ul>
      <li>Scalabilité
        <p>
          Les micro-services peuvent être mis à l'échelle indépendemment des autres.

        </p>
      </li>
      <li>Fiabilité
        <p>
          Il est plus simple de tester un micro-service qu'un gros monolythe.
          De plus, on peut faire en sorte de découpler les micro-services
          pour qu'un problème sur une brique de l'application n'affecte pas les autres.
          On a alors un mode dégradé qui peut être peu handicapant voire transparent vis à vis de l'utilisateur.
          On augmente ainsi la disponibilité du service.
        </p>
      </li>
      <li>Évolutivité
        <p>
          Son indépendance permet de faire évoluer le micro-service de manière beaucoup plus rapide.
        </p>
      </li>
      <li>Autonomie des équipes
        <p>
          Les équipes gagnent en autonomie car au délà de l'interface qu'elles affiche par leur API,
          elles sont libres de faire les choix qui leur conviennent le mieux.
        </p>
      </li>
      <li>Applications polyglottes
          <p>
            Un langage différent peut être utilisé pour chaque micro-service.
            Chacun d'entre eux échange des données via des formats indépendants du langage
            et supporté très largement comme XML ou JSON.
            Cela permet de choisir le langage le plus adapté à la fonction du service.
          </p>
        </li>
    </ul>

    <h3>Inconvénients</h3>
    <ul>
      <li>Complexité pour déployer
        <p>
          Il faut réussir à gérer de nombreuses instances en même temps
          et savoir les passer à l'échelle.
          Cette tâche est loin d'être triviale mais des outils d'automatisation
          comme docker et kubernetes permettent de rendre les choses plus simples.
          D'une part Docker permet de travailler sur un environment toujours identique
          indépendemment de la machine (il s'agit de conteneurisation).
          D'autre part, Kubernetes permet l'orchestrationn de tous ces conteneurs.
        </p>
      </li>
      <li>Architecture plus complexe (monitoring et maintenance)
        <p>
          On multiplie le nombre d'instances et de base de données donc l'infrastructure devient plus complexe.
          Ceci pose notamment un problème pour le monitoring et la maintenance.
          Mais des outils existent pour surveiller le fonctionnement des micro-services (Prometheus, Kibana, Graphana)
        </p>
      </li>
      <li>Communication entre services
        <p>
          On ajoute une couche de complexité en devant assurer la communication entre les différents services
          de manière synchrone ou asynchrone selon les besoins de l'application.
        </p>
      </li>
      <li>Cohérence des données
        <p>
          Il est plus difficile d'assurer la cohérence des données dans un système distribué
          car on ne peut pas garantir l'atomicité des opérations sur la base de données.
        </p>
      </li>
    </ul>

  </section>

  

  <footer>
    This is a footer

  </footer>
</body>

</html>
